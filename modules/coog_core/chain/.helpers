# vim: set ft=sh:
# chain helpers ($CHAIN_NAME and $CHAIN_FILE are supposed to be set)

ensure_output_name() {
    CHAIN_FILE="${CHAIN_FILE:-/tmp/$HOSTNAME-$CHAIN_NAME-$(date +'%y%m%d-%H%M')}"
}

chain_begin() {
    ensure_output_name
    {
        echo "################################"
        echo "$CHAIN_NAME: OK"
        echo "started @ $(date +'%H:%M:%S')"
        echo "################################"
        echo
    } >> "$CHAIN_FILE"
}

chain_params() {
    # This magic method create and set global variables
    # according to parameters given to the chain
    GIVEN_PARAMETERS=()
    for i in "$@"
    do
        local PARAM_NAME=`expr match "$i" ' *--\([^= ]*\)=' | awk '{ print toupper($1) }'`
        local PARAM_VALUE="${i#*=}"
        if [[ " ${CHAIN_PARAMETERS[*]} " == *" $PARAM_NAME "* ]]
        then
            if [[ -z $PARAM_VALUE ]]
            then
                PARAM_VALUE=""
            else
                printf -v $PARAM_NAME $PARAM_VALUE
            fi
            GIVEN_PARAMETERS+=("$i")
        else
            echo "Unknown batch chain parameter:" `echo $PARAM_NAME | awk '{ print tolower($1) }' `>&2
        fi
    done

    local FAILED=0
    for i in "${CHAIN_REQUIRED[@]}"
    do
        if [[ -z ${!i} ]]
        then
            if [[ $i == "TREATMENT_DATE" ]] && [[ -n "$WORKING_DAYS" ]]; then
                echo "Skipping treatment_date parameter, using working_days" >&2
                continue
            elif [[ $i == "WORKING_DAYS" ]] && [[ -n "$TREATMENT_DATE" ]]; then
                echo "Skipping working_days parameter, using treatment_date" >&2
                continue
            elif [[ $i == "CONF_CODE" ]] && [[ -n "$TREATMENT_DATE" ]]; then
                echo "Skipping conf_code parameter, using treatment_date" >&2
                continue
            fi
            echo "Missing batch chain parameter:" `echo $i | awk '{ print tolower($1) }'` >&2
            FAILED+=1
        fi
    done
    [[ $FAILED -gt 0 ]] && exit 1
}

chain_step() {
    echo '=>=>=>=>=>'
    coog_batch_exec "$@" --chain_name="$CHAIN_NAME" 2>&1 &
}

chain_wait() {
    local ret=0
    ensure_output_name
    for pid in $(jobs -p)
    do
        wait "$pid" || ret=1
    done
    while [ ! -z "$1" ]
    do
        coog_batch_report "$1" >> "$CHAIN_FILE"
        shift
    done
    if [ "$ret" -eq 0 ]
    then
        echo '<=<=<=<=<= ok' && return 0
    else
        echo '<=<=<=<=<= ko' && return 1
    fi
}

chain_end() {
    local ret=$?
    ensure_output_name
    sed -i -e 's/\\n/\n/g' "$CHAIN_FILE"
    sed -i -e "/^started @/ a ended @ $(date +'%H:%M:%S')" "$CHAIN_FILE"
    if [ $ret -ne 0 ]
    then
        sed -i -e "s/$CHAIN_NAME: OK/$CHAIN_NAME: KO/g" "$CHAIN_FILE"
        cat "$CHAIN_FILE" >&2
        echo "========== $CHAIN_FILE"
        exit $ret
    else
        cat "$CHAIN_FILE"
        echo "========== $CHAIN_FILE"
        rm -f "$CHAIN_FILE"
        exit 0
    fi
}
