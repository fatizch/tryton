#!/bin/bash
# docker entrypoint

COOG_ROOT=/opt/coog
COOG_TRYTOND=$COOG_ROOT/trytond
COOG_BIN=$COOG_ROOT/coog/bin
COOG_CONF=$COOG_ROOT/coog.conf
COOG_DATA=$COOG_ROOT/data

###########
# helpers #
###########

linked_redis_host() {
        echo $REDIS_PORT_6379_TCP_ADDR
}

linked_redis_port() {
        echo $REDIS_PORT_6379_TCP_PORT
}

linked_postgres_host() {
        echo $POSTGRES_PORT_5432_TCP_ADDR
}

linked_postgres_port() {
        echo $POSTGRES_PORT_5432_TCP_PORT
}

hash_pwd() {
        python2 -c "import crypt,random,string; print crypt.crypt('$1', ''.join(random.sample(string.ascii_letters + string.digits, 8)))"
}

################
# build config #
################

conf_jsonrpc() {
        echo "[jsonrpc]" >> $COOG_CONF
        echo "listen = 0.0.0.0:8000" >> $COOG_CONF
}

conf_xmlrpc() {
        echo "[xmlrpc]" >> $COOG_CONF
        echo "listen = 0.0.0.0:8069" >> $COOG_CONF
}

conf_database() {
        echo "[database]" >> $COOG_CONF
        local db_system
        [ ! -z $COOG_DB_SYS ] && db_system=$COOG_DB_SYS
        [ -z $db_system ] && db_system=postgresql
        local db_host
        [ ! -z $COOG_DB_HOST ] && db_host=$COOG_DB_HOST
        [ -z $db_host ] && [ $db_system = postgresql ] && db_host=`linked_postgres_host`
        [ -z $db_host ] && echo "no db host defined" && return 1
        local db_port
        [ ! -z $COOG_DB_PORT ] && db_port=$COOG_DB_PORT
        [ -z $db_port ] && [ $db_system = postgresql ] && db_port=`linked_postgres_port`
        [ -z $db_port ] && echo "no db port defined" && return 1
        local db_user
        [ ! -z $COOG_DB_USER ] && db_user=$COOG_DB_USER
        [ -z $db_user ] && echo "no db user defined" && return 1
        local db_password
        [ ! -z $COOG_DB_PASSWORD ] && db_password=$COOG_DB_PASSWORD
        [ -z $db_password ] && echo "no db password defined" && return 1
        echo "uri = $db_system://$db_user:$db_password@$db_host:$db_port" >> $COOG_CONF
        echo "path = $COOG_DATA" >> $COOG_CONF
        [ ! -z $COOG_DB_LANG ] && echo "language = $COOG_DB_LANG" >> $COOG_CONF
        return 0
}

conf_cache() {
        echo "[cache]" >> $COOG_CONF
        [ ! -z $COOG_CACHE_MODEL ] && echo "model = $COOG_CACHE_MODEL" >> $COOG_CONF
        [ ! -z $COOG_CACHE_RECORD ] && echo "record = $COOG_CACHE_RECORD" >> $COOG_CONF
        [ ! -z $COOG_CACHE_FIELD ] && echo "field = $COOG_CACHE_FIELD" >> $COOG_CONF
        [ ! -z $COOG_CACHE_COOG ] && echo "coog_cache_size = $COOG_CACHE_COOG" >> $COOG_CONF
        local cache_sys
        [ ! -z $COOG_CACHE_SYS ] && cache_sys=$COOG_CACHE_SYS
        [ -z $cache_sys ] && return 0
        local cache_host
        [ ! -z $COOG_CACHE_HOST ] && cache_host=$COOG_CACHE_HOST
        [ -z $cache_host ] && cache_host=`linked_redis_host`
        [ -z $cache_host ] && echo "no cache host defined" && return 1
        local cache_port
        [ ! -z $COOG_CACHE_PORT ] && cache_port=$COOG_CACHE_PORT
        [ -z $cache_port ] && cache_port=`linked_redis_port`
        [ -z $cache_port ] && echo "no cache port defined" && return 1
        local cache_db
        [ ! -z $COOG_CACHE_DB ] && cache_db=$COOG_CACHE_DB
        [ -z $cache_db ] && echo "no cache db defined" && return 1
        echo "redis = redis://$cache_host:$cache_port/$cache_db" >> $COOG_CONF
}

conf_async() {
        echo "[async]" >> $COOG_CONF
        local async_sys
        [ ! -z $COOG_ASYNC_SYS ] && async_sys=$COOG_ASYNC_SYS
        [ -z $async_sys ] && return 0
        local async_host
        [ ! -z $COOG_ASYNC_HOST ] && async_host=$COOG_ASYNC_HOST
        [ -z $async_host ] && async_host=`linked_redis_host`
        [ -z $async_host ] && echo "no async host defined" && return 1
        local async_port
        [ ! -z $COOG_ASYNC_PORT ] && async_port=$COOG_ASYNC_PORT
        [ -z $async_port ] && async_port=`linked_redis_port`
        [ -z $async_port ] && echo "no async port defined" && return 1
        local async_db
        [ ! -z $COOG_ASYNC_DB ] && async_db=$COOG_ASYNC_DB
        [ -z $async_db ] && echo "no async db defined" && return 1
        echo "$async_sys = redis://$async_host:$async_port/$async_db" >> $COOG_CONF
        [ $COOG_ASYNC_SYS = rq ] && export TRYTOND_ASYNC_RQ="redis://$async_host:$async_port/$async_db"
        [ $COOG_ASYNC_SYS = celery ] && export TRYTOND_ASYNC_CELERY="redis://$async_host:$async_port/$async_db"
}

conf_session() {
        echo "[session]" >> $COOG_CONF
        [ -z $COOG_SESSION_SUPERPWD ] && return 0
        local password
        password=`hash_pwd $COOG_SESSION_SUPERPWD`
        echo "super_pwd = $password" >> $COOG_CONF
}

conf_report() {
        echo "[report]" >> $COOG_CONF
        echo "unoconv = pipe,name=trytond;urp;StarOffice.ComponentContext" >> $COOG_CONF
}

conf_sentry() {
        echo "[sentry]" >> $COOG_CONF
        local sentry_protocol
        [ ! -z $COOG_SENTRY_PROTOCOL ] && sentry_protocol=$COOG_SENTRY_PROTOCOL
        [ -z $sentry_protocol ] && sentry_protocol=http
        local sentry_host
        [ ! -z $COOG_SENTRY_HOST ] && sentry_host=$COOG_SENTRY_HOST
        [ -z $sentry_host ] && return 0
        local sentry_port
        [ ! -z $COOG_SENTRY_PORT ] && sentry_port=$COOG_SENTRY_PORT
        [ -z $sentry_port ] && echo "no sentry port defined" && return 1
        local sentry_pub
        [ ! -z $COOG_SENTRY_PUB ] && sentry_pub=$COOG_SENTRY_PUB
        [ -z $sentry_pub ] && echo "no sentry dsn pub key defined" && return 1
        local sentry_sec
        [ ! -z $COOG_SENTRY_SEC ] && sentry_sec=$COOG_SENTRY_SEC
        [ -z $sentry_sec ] && echo "no sentry dsn sec key defined" && return 1
        local sentry_project
        [ ! -z $COOG_SENTRY_PROJECT ] && sentry_project=$COOG_SENTRY_PROJECT
        [ -z $sentry_project ] && echo "no sentry dsn project defined" && return 1
        echo "dsn = $sentry_protocol://$sentry_pub:$sentry_sec@$sentry_host:$sentry_port/$sentry_project" >> $COOG_CONF
}

conf_batch() {
        echo "[batch]" >> $COOG_CONF
        echo "root_dir = $COOG_DATA" >> $COOG_CONF
}

conf() {
        conf_jsonrpc && \
                conf_xmlrpc && \
                conf_database && \
                conf_cache && \
                conf_async && \
                conf_session && \
                conf_report && \
                conf_sentry && \
                conf_batch
        [ $? -ne 0 ] && echo "!!! Failed to build configuration file !!!" && return 1
        local override
        override=$COOG_DATA/coog.conf
        [ -f $override ] && cat $override >> $COOG_CONF
        return 0
}

###############
# entrypoints #
###############

dep() {
        . $COOG_BIN/coog-dep
        coog_dep_base && coog_dep_extend && coog_dep_batch
}

link() {
        . $COOG_BIN/coog-repo
        coog_repo_linkm
}

version() {
        cat $COOG_ROOT/.version
}

print_env() {
        echo before conf
        printenv
        conf || return $?
        echo
        echo after conf
        printenv
}

print_conf() {
        conf || return $?
        cat $COOG_CONF
}

app() {
        echo Welcome on board, Coog is preparing to start
        conf || return $?
        echo Starting unoconv
        # done twice - unoconv issue - https://github.com/dagwieers/unoconv/issues/326
        unoconv --listener -c "pipe,name=trytond;urp;StarOffice.ComponentContext" &
        sleep 3
        unoconv --listener -c "pipe,name=trytond;urp;StarOffice.ComponentContext" &
        echo Starting app
        export PYTHONUNBUFFERED=1
        export PYTHONPATH="$COOG_TRYTOND:$PYTHONPATH"
        local args
        args="-c $COOG_CONF"
        [ ! -z $COOG_DB_NAME ] && args="$args -d $COOG_DB_NAME"
        trytond $args $*
}

batch_redis() {
        python2 $COOG_BIN/.py/evalredis.py $* < $COOG_BIN/redis/batch.lua
}

batch_generate() {
        [ $# -lt 2 ] && echo missing arguments && return 1
        local broker; broker=$1; shift
        local name; name=$1; shift
        local waiting; waiting=`batch_redis count $broker $name 'wait'` || return 1
        [ $waiting -ne 0 ] && echo queue not empty && return 1
        python2 -m "batch-generate" -b $broker -n $name $*
}

batch_split() {
        [ $# -lt 2 ] && echo missing arguments && return 1
        local broker; broker=$1; shift
        local name; name=$1; shift
        local waiting; waiting=`batch_redis count $broker $name 'wait'` || return 1
        [ $waiting -ne 0 ] && echo queue not empty && return 1
        batch_redis backup $broker $name || return 1
        local head; head=1
        batch_redis list $broker $name |
        while IFS= read -r fail
        do
                [ $head -eq 1 ] && head=0 && continue
                local id; id=`echo $fail | cut -d " " -f 2`
                local key; key=`batch_redis key $broker $id` || return 1
                python2 -m "batch-split" $broker $key && batch_redis archive $broker $id
                [ $? -ne 0 ] && return $?
        done
        return 0
}

batch_rq() {
        local i=0
        while [ $i -lt $2 ]
        do
                i=$((i+1))
                rq worker --burst -u $TRYTOND_ASYNC_RQ -n "$1"-"$i" $1 &
        done
}

batch_celery() {
        celery worker --loglevel=$LOG_LEVEL --app=async.broker_celery --queues=$1 --concurrency=$2 &
}

batch_wait() {
        [ $# -lt 2 ] && echo missing arguments && return 1
        local broker; broker=$1; shift
        local name; name=$1; shift
        while [ true ]
        do
                local waiting; waiting=`batch_redis count $broker $name 'wait'` || return 1
                [ $waiting -eq 0 ] && break
                echo "wait @ "`date +"%H:%M:%S"`" - $waiting"
                sleep 10
        done
        local failed; failed=`batch_redis count $broker $name 'fail'`
        [ $failed -eq 0 ] && echo batch execution succeeded && return 0
        echo "$failed jobs failed"
        local head; head=1
        batch_redis list $broker $name fail |
        while IFS= read -r fail
        do
                [ $head -eq 1 ] && head=0 && continue
                local id; id=`echo $fail | cut -d " " -f 2`
                batch_redis show $broker $id
                echo
        done
        return 1
}

batch() {
        conf || return $?
        [ -z $COOG_ASYNC_SYS ] && echo "no async broker defined" && return 1
        export PYTHONUNBUFFERED=1
        [ -z $1 ] && echo missing action && return 1
        local action; action=$1; shift
        local gen_api;
        if [ $action = query ]
        then
                [ -z $1 ] && echo missing command && return 1
                local cmd; cmd=$1; shift
                batch_redis $cmd $COOG_ASYNC_SYS $*
                return $?
        elif [ $action = exec ]
        then
                gen_api=generate
        elif [ $action = retry ]
        then
                gen_api=split
        else
                echo "possible actions: exec - retry - query" && return 1
        fi
        echo Welcome on board, Coog is preparing to start
        echo Starting unoconv
        # done twice - unoconv issue - https://github.com/dagwieers/unoconv/issues/326
        unoconv --listener -c "pipe,name=trytond;urp;StarOffice.ComponentContext" &
        sleep 3
        unoconv --listener -c "pipe,name=trytond;urp;StarOffice.ComponentContext" &
        echo Starting batch
        export PYTHONPATH="$COOG_BIN/lib:$COOG_TRYTOND:$PYTHONPATH"
        export TRYTOND_CONFIG="$COOG_CONF"
        export DB_NAME=$COOG_DB_NAME
        export LOG_LEVEL=WARNING
        [ -z $1 ] && echo missing batch name && return 1
        local name; name=$1; shift
        [ -z $1 ] && echo missing workers number && return 1
        local nb; nb=$1; shift
        batch_$gen_api $COOG_ASYNC_SYS $name $* && batch_$COOG_ASYNC_SYS $name $nb && batch_wait $COOG_ASYNC_SYS $name
}

########
# main #
########

main() {
        [ -z $1 ] && echo Possible commands: version - env - config - app - batch && return 1
        [ $1 = dep ] && { shift; dep $*; return $?; }
        [ $1 = link ] && { shift; link $*; return $?; }
        [ $1 = version ] && { shift; version $*; return $?; }
        [ $1 = env ] && { shift; print_env $*; return $?; }
        [ $1 = config ] && { shift; print_conf $*; return $?; }
        [ $1 = app ] && { shift; app $*; return $?; }
        [ $1 = batch ] && { shift; batch $*; return $?; }
        echo Not supported command && return 1
}

main $*
